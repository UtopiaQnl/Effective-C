extern void func(int i);  // Явная внешняя компоновка


static void bar(void)
{  // Внутренная компоновка, bar не из foo.c
    func(12);  // Вызывает func из foo.c
    // [ОПРЕДЕЛЕНИЕ КОТОРОГО В foo.c, а объявление тут и оно внешее] ...?
}


void baz(int k)
{  // Неявная внешняя компоновка
    bar();  // Вызывает bar из bar.c, не foo.c
}

// Компоновка объявления либо указывается явно, либо подразумевается
// неявно. Если вы объявляете сущность на уровне файла без использова-
// ния спецификаторов extern и static, то ей неявно назначается внешняя
// компоновка.

int i;  // Внешняя компоновка; не конфликтует с i из foo.c и bar.с
extern int i;  // если будет такое объявление одно, то пример выше эквивалентен?

// Что на счет extern в блоке (например, функции)

// К сущностям без компоновки относятся:
//
//      1 Параметры функций.
//
//      2 Идентификаторы, объявляемые на уровне блока без применения
//        спецификатора класса хранения extern.
//
//      3 Константы-перечисления.
//
